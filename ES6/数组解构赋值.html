<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        /*
         解构赋值:
         有对象的和数组的解构赋值
        */

        // 1.对象的解构赋值

        // 以前为变量赋值
        // let a = 1;
        // let b = 2;
        // let c = 3;
        // ES6允许写法
        // let [a, b, c] = [1, 2, 3];
        // console.log(a, b, c);//1  2  3

        // 嵌套数组进行解构的例子

        // 以前写法
        // var arr = [11, [[22], 33]];
        // let [a, [[b], c]] = arr;
        // console.log(a, b, c);//  11 22  33

        // ES6写法
        // let [a, [[b], c]] = [11, [[22], 33]]
        // console.log(a, b, c);//  11 22  33

        //解构不成功
        // let [a, b, c] = [1];
        // console.log(c);   //undefined

        // let [a] = [];
        // console.log(a);//undefined

        // 不完全解构,但是可以成功
        // let [a, b, c] = [1, 2];
        // console.log(a, b);//1,2

        // let [a, [[b], d]] = [1, [[2, 3], 4]];
        // console.log(a, b, d);//1,2,4

        //如果等号的右边不是数组   报错
        //	let [foo] = 1; //数字不能解构
        //	let [foo] = false;  //布尔值不能解构
        //	let [foo] = NaN; //NaN也不能解构
        //	let [foo] = undefined;//
        //	let [foo] = null;
        //	let [foo] = {};
        //	let [fn] = function fn2(){}

        //小总结，如果使用数组的方式去解构，那么除了数组别的数据解构都报错

        // 默认值
        // 解构赋值允许指定默认值

        // let [a = true] = [];
        // console.log(a);//true

        // let [a, b = a] = [1];
        // console.log(a, b);;// 1 1

        // 有配置走配置，没配置走默认
        // let [a, b = 2] = [1, 22];
        // console.log(a, b);//1 22

        // let [a, b = 2] = [1];
        // console.log(a, b);//1 2
        // ES6 内部使用严格相等运算符（===），判断一个位置是否有值。
        // 所以，只有当一个数组成员严格等于undefined，默认值才会生效。
        // let [a, b] = [1, undefined];
        // console.log(a, b);//1,undefined

        // let [a, b = 2] = [1, undefined];
        // console.log(a, b);//1,2

        // 如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。
        // let [a = 1] = [undefined];
        // console.log(a);//1
        // let [b = 2] = [null];
        // console.log(b);//null

        /*
        	
            如果一个数组中有个变量且这个变量没有赋值，那么会报错
        	
            当使用解构赋值之后（前提条件用var来声明解构），数组不会因为a而报错
        	
            这个时候发生什么事呢？
        	
                解构之后，如果使用了var，那么会先给左边的变量预解析，
                然后右边赋值给左边，左边再去读取刚才右边的每个值。
        	
        	
            ***使用let的时候一定要注意没有预解析的问题。
        */

        // 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
        function f() {
            console.log('aaa');
        }

        // let [x = f()] = [1];

        // console.log(x); //1

        // 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。

        // let x;
        // if ([1][0] === undefined) {
        //     x = f();
        // } else {
        //     x = [1][0];
        // }
        // console.log(x)
        // 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
        let [x = 1, y = x] = [];     // x=1; y=1
        let [x = 1, y = x] = [2];    // x=2; y=2
        let [x = 1, y = x] = [1, 2]; // x=1; y=2
        let [x = y, y = 1] = [];     // ReferenceError: y is not defined
        // 上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。

    </script>
</body>

</html>